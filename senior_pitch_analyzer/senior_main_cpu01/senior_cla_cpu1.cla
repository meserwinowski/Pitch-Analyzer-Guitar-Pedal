/*
 * senior_cla_cpu1.cla
 *
 *  Created on: Nov 17, 2018
 *      Author: meser
 */

#include "F28379D_Senior_Design.h"

extern uint16_t GPIO34_count;

extern volatile LED_DATA frameLUT[6][25];
extern volatile float32 fo_n_cpu1[7];

/**********************************************************************
* Task: CLA Task 1 - Update LUT, Output display frame to LED Matrix - Increment Status LED
**********************************************************************/
interrupt void Cla1Task1 (void) {
    uint16_t i;         // Local variables for indexing
    uint16_t j;
    uint16_t fret;
    int16_t string;
    int16_t note_index;
    uint32_t LEDdata;   // Holds LED data
    uint_fast8_t temp;      // Temporary variable for reading SPI RX

//    __mdebugstop();     // Debug Stop

    /* Update LUT */
    for (string = 1; string < 7; string++) {
        note_index = (int16_t) fo_n_cpu1[string];
        if (note_index >= 1) {
            frameLUT[string - 1][note_index].red = 0x1F;
        }
        else if (note_index == 0) {
//            __mdebugstop();     // Debug Stop
            for (i = 0; i < 25; i++) {
                frameLUT[string - 1][i].red = 0x00;
                frameLUT[string - 1][i].green = 0x00;

            }
        }
    }

    /* Send Start Frame */
    LEDdata = START_FRAME;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++) {
            // Fill Transmit Buffer
            SpiaRegs.SPITXBUF = ((LEDdata & 0xFF000000) >> 16);

            // Wait for Receive Buffer to Fill
            while(SpiaRegs.SPIFFRX.bit.RXFFST != 1);

            // Read Receive Buffer
            temp = SpiaRegs.SPIRXBUF;

            // Shift data for next byte
            LEDdata = LEDdata << 8;
        }
    }

    /* Send LUT Data */
    for (fret = 1; fret < 25; fret++) {
        string = 5;
        for (string = 5; string >= 0; string--) {
            SpiaRegs.SPITXBUF = frameLUT[string][fret].sbright << 8;
            while(SpiaRegs.SPIFFRX.bit.RXFFST != 1);
            temp = SpiaRegs.SPIRXBUF;
            SpiaRegs.SPITXBUF = frameLUT[string][fret].blue << 8;
            while(SpiaRegs.SPIFFRX.bit.RXFFST != 1);
            temp = SpiaRegs.SPIRXBUF;
            SpiaRegs.SPITXBUF = frameLUT[string][fret].green << 8;
            while(SpiaRegs.SPIFFRX.bit.RXFFST != 1);
            temp = SpiaRegs.SPIRXBUF;
            SpiaRegs.SPITXBUF = frameLUT[string][fret].red << 8;
            while(SpiaRegs.SPIFFRX.bit.RXFFST != 1);
            temp = SpiaRegs.SPIRXBUF;
        }
    }

    /* Send End Frame */
    LEDdata = END_FRAME;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++) {
            // Fill Transmit Buffer
            SpiaRegs.SPITXBUF = ((LEDdata & 0xFF000000) >> 16);

            // Wait for Receive Buffer to Fill
            while(SpiaRegs.SPIFFRX.bit.RXFFST != 1);

            // Read Receive Buffer
            temp = SpiaRegs.SPIRXBUF;

            // Shift data for next byte
            LEDdata = LEDdata << 8;
        }
    }

    /* Decay LUT Data */
    if ((GPIO34_count & 0x255) == 1) {
        __mdebugstop();     // Debug Stop
        for (fret = 1; fret < 25; fret++) {
            __mdebugstop();     // Debug Stop
            for (string = 0; string < 6; string++) {
                __mdebugstop();     // Debug Stop
                temp = frameLUT[string][fret].blue;
                if (temp > 0) {
                    frameLUT[string][fret].blue--;
                }
    //            temp = frameLUT[string][fret].blue;
    //            if (temp > 0) {
    //                frameLUT[string][fret].blue = temp - 1;
    //            }
    //            temp = frameLUT[string][fret].green;
    //            if (temp > 0) {
    //                frameLUT[string][fret].green = temp - 1;
    //            }
            }
        }
    }

    /* Increment Count for Status LED */
    GPIO34_count += 1;

}

/**********************************************************************
* Task: CLA Task 2 - Decay brightness in LUT
**********************************************************************/
interrupt void Cla1Task2 (void) {

}

/**********************************************************************
* Task: CLA Task 3
**********************************************************************/
interrupt void Cla1Task3 (void) {

}

/**********************************************************************
* Task: CLA Task 4
**********************************************************************/
interrupt void Cla1Task4 (void) {

}

/**********************************************************************
* Task: CLA Task 5
**********************************************************************/
interrupt void Cla1Task5 (void) {

}

/**********************************************************************
* Task: CLA Task 6
**********************************************************************/
interrupt void Cla1Task6 (void) {

}

/**********************************************************************
* Task: CLA Task 7
**********************************************************************/
interrupt void Cla1Task7 (void) {

}

/**********************************************************************
* Task: CLA Task 8
*
* The delay elements xDelay are placed in the section Cla1ToCpuMsgRAM.
* The C28x does not have write access to this array. Therefore, this
* array will not be initialized at startup time by the cinit routine.
* The purpose of this task is to do a one-time initialization of the
* delay buffer and set the elements to zero.
**********************************************************************/
interrupt void Cla1Task8 (void) {

}

// End of File
